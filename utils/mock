#!/usr/bin/env python3

import argparse
import logging
import threading
import signal
import sys
import socket
import socketserver
import parsimonious.grammar
import parsimonious.nodes

unit = {
    'info': {
        'sensor': 1,
        'snsversion': 2,
        'hwver': 123,
        'kernel': 456,
        'swver': 135,
        'xver': 246,
        'xmax': 2048,
        'ymax': 1952,
        'serial': 123456,
        'name': 'Phantom v2640',
    },
    'video': {
        'paox': 0,
        'paoy': 0,
    },
    'defc': {
        'exp': 10 * 1000 * 1000,    # = 10 ms
    }
}

grammar = parsimonious.grammar.Grammar(r"""
    value = space (tagged_list / resolution / unsigned / signed / string / hex_number / var_name) space
    unsigned = ~"[1-9][0-9]*"
    signed = "-" unsigned
    hex_number = ~"0x[A-Fa-f0-9]+"
    string = "\"" text "\""
    resolution = unsigned "x" unsigned
    var_name = identifier ("." identifier)*
    identifier = ~"[A-Za-z][A-Za-z0-9]*"
    tagged_list = list_open space key_value ("," space key_value)* space list_close
    list_open = "{"
    list_close = "}"
    key_value = var_name space ":" space value
    text = ~"[^\"]*"
    space = ~"\s*"
""")


class Visitor(parsimonious.nodes.NodeVisitor):
    def generic_visit(self, node, children):
        return children if children else None

    def visit_identifier(self, node, children):
        return node.text

    def visit_unsigned(self, node, children):
        return int(node.text)

    def visit_signed(self, node, children):
        return int(node.text)

    def visit_hex_number(self, node, children):
        return int(node.text, 0)

    def visit_string(self, node, children):
        _, text, _ = children
        return text

    def visit_resolution(self, node, children):
        width, _, height = children
        return (width, height)

    def visit_tagged_list(self, node, children):
        _, _, (key, value), _, _, _ = children
        return {key: value}

    def visit_key_value(self, node, children):
        key, _, _, _, value = children
        return (key, value)

    def visit_var_name(self, node, children):
        return node.text

    def visit_value(self, node, children):
        _, value, _ = children
        return value[0]


def to_python(s):
    return Visitor().visit(grammar.parse(s))


class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass


class ThreadedUDPServer(socketserver.ThreadingMixIn, socketserver.UDPServer):
    pass


class DiscoveryInterface(socketserver.BaseRequestHandler):
    def handle(self):
        data, socket = self.request
        logging.debug('Discovery request from {}'.format(socket))
        message = 'PH16 7115 {} {}'.format(unit['info']['hwver'], unit['info']['serial'])
        socket.sendto(message.encode('utf-8'), self.client_address)


class ControlInterface(socketserver.BaseRequestHandler):
    def setup(self):
        self.data_socket = None
        self.data_thread = None

    def handle(self):
        while True:
            data = self.request.recv(512).strip()
            cmd = data.decode('utf-8').split(' ')

            if cmd and cmd[0] == '':
                continue

            handle = getattr(self, 'handle_' + cmd[0])

            if not handle(cmd[1:]):
                break

    def send(self, message):
        self.request.sendall('{}\r\n'.format(message).encode('utf-8'))

    def send_error(self, message):
        self.send('ERR: {}'.format(message))

    def handle_get(self, data):
        var = data[0]
        logging.debug('GET {}'.format(var))

        try:
            x = unit
            for p in var.split('.'):
                x = x[p]
        except KeyError as e:
            self.send_error('name {} is unknown'.format(e.args[0]))

        self.send(str(x))
        return True

    def handle_set(self, data):
        var, value = data
        logging.debug('SET {}={}'.format(var, value))

        try:
            path = var.split('.')
            x = unit

            for p in path[:-1]:
                x = x[p]

            v = path[-1]
            t = type(x[v])
            x[v] = t(value)
        except KeyError as e:
            self.send_error('name {} is unknown'.format(e.args[0]))

        self.send('Ok!')
        return True

    def push_data(self):
        while True:
            try:
                self.data_socket.sendall('hello here are some cookies'.encode('utf-8'))
            except ConnectionResetError:
                # is server allowed to reset connection?
                pass
            except BrokenPipeError:
                pass

    def handle_startdata(self, data):
        try:
            params = to_python(''.join(data))
            port = params['port']
            host, _ = self.request.getpeername()
            logging.debug('Connecting to {}:{}'.format(host, port))
            self.data_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.data_socket.connect((host, port))
            self.data_thread = threading.Thread(target=self.push_data)
            self.data_thread.start()
            self.send('Ok!')
        except parsimonious.exceptions.ParseError as e:
            logging.error("Could not parse {}: {}".format(data, str(e)))
            self.send_error('missing command args')

        return True

    def handle_ximg(self, data):
        self.send('Ok')
        return True

    def handle_bye(self, data):
        return False


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', action='store_true', default=False)
    args = parser.parse_args()

    level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=level, datefmt='%Y-%m-%d %H:%M:%S', format='%(asctime)s %(name)s %(levelname)s %(message)s')

    servers = [
        ThreadedUDPServer(('0.0.0.0', 7380), DiscoveryInterface),
        ThreadedTCPServer(('0.0.0.0', 7115), ControlInterface)
    ]

    threads = [threading.Thread(target=s.serve_forever) for s in servers]

    for thread in threads:
        thread.daemon = True
        thread.start()

    def sigint_handler(signal, frame):
        for server in servers:
            logging.info("Shutting down {}:{}".format(*server.server_address))
            server.shutdown()
            server.server_close()

    signal.signal(signal.SIGINT, sigint_handler)
    logging.info("Press Ctr+C to stop servers ...")
    signal.pause()
